<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì‹œí—˜ê¸°ê°„ ìŠ¤íŠ¸ë ˆìŠ¤ í•´ì†Œìš© ì‹œí—˜ì§€ ë¿Œì‹œê¸° ê²Œì„</title>
  <style>
    body { margin: 0; background: #111; color: #fff; font-family: system-ui, sans-serif; }
    .wrap { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 12px; }

    .title {
      width: 360px; max-width: 95vw;
      font-size: 16px; font-weight: 800;
      padding: 12px 12px;
      border-radius: 14px;
      text-align: center;
      color: #ffe66b;
      background: linear-gradient(180deg, rgba(255,230,107,0.10), rgba(0,0,0,0.25));
      border: 1px solid rgba(255,230,107,0.35);
      text-shadow: 0 1px 0 rgba(0,0,0,0.55);
      letter-spacing: -0.2px;
    }

    canvas {
      background: #1b1b1b;
      border: 1px solid #333;
      border-radius: 12px;
      touch-action: manipulation;
    }

    /* HUD: í•„ìš”í•œ ì •ë³´ë§Œ ë‚¨ê¹€(í•™ë…„/ì§„í–‰) */
    .hud {
      width: 360px; max-width: 95vw;
      display: grid; grid-template-columns: 1fr 1fr;
      gap: 6px; font-size: 14px; opacity: 0.95;
    }
    .hud > div { background: rgba(255,255,255,0.06); padding: 8px 10px; border-radius: 10px; }

    .btns { width: 360px; max-width: 95vw; display: flex; gap: 8px; }
    button { flex: 1; padding: 10px 12px; border-radius: 10px; border: 0; cursor: pointer; }

    .footer {
      width: 360px; max-width: 95vw;
      text-align: center;
      font-size: 12px;
      opacity: 0.65;
      padding: 6px 0 2px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">ì‹œí—˜ê¸°ê°„ ìŠ¤íŠ¸ë ˆìŠ¤ í•´ì†Œìš© ì‹œí—˜ì§€ ë¿Œì‹œê¸° ê²Œì„</div>

    <!-- í†µê³¼ì¡°ê±´/ìƒíƒœëŠ” ìˆ¨ê¸°ê³ , í•„ìš”í•œ ê²ƒë§Œ í‘œì‹œ -->
    <div class="hud">
      <div id="grade">í•™ë…„: ì¤‘í•™êµ 1í•™ë…„</div>
      <div id="progress">ì§„í–‰: 0 / 10 (í´ë¦­: 0)</div>
    </div>

    <canvas id="game" width="360" height="640"></canvas>

    <div class="btns">
      <button id="startBtn">ì‹œì‘</button>
      <button id="restartBtn">ë¦¬ì…‹</button>
      <button id="muteBtn">ğŸ”Š ìŒì•…</button>
    </div>

    <div class="footer">Created by Chiyona</div>
  </div>

  <script>
    // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (window.__PAPER_GAME_LOADED__) {
      console.warn("Game already loaded - preventing duplicate init.");
      throw new Error("Duplicate load prevented");
    }
    window.__PAPER_GAME_LOADED__ = true;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const gradeEl = document.getElementById("grade");
    const progressEl = document.getElementById("progress");

    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const muteBtn = document.getElementById("muteBtn");

    // ìŠ¤í…Œì´ì§€ ê·œì¹™
    const STAGES = [
      { label: "ì¤‘í•™êµ 1í•™ë…„", total: 10, pass: 5,  school: "middle" },
      { label: "ì¤‘í•™êµ 2í•™ë…„", total: 15, pass: 10, school: "middle" },
      { label: "ì¤‘í•™êµ 3í•™ë…„", total: 20, pass: 15, school: "middle" },
      { label: "ê³ ë“±í•™êµ 1í•™ë…„", total: 25, pass: 20, school: "high"   },
      { label: "ê³ ë“±í•™êµ 2í•™ë…„", total: 30, pass: 25, school: "high"   },
      { label: "ê³ ë“±í•™êµ 3í•™ë…„", total: 35, pass: 30, school: "high"   },
    ];

    // ë¹„ì£¼ì–¼
    const PAPER_W = 92;
    const PAPER_H = 58;

    function getPaperStyle() {
      const school = STAGES[stageIndex].school;
      if (school === "high") {
        return {
          fill: "#ffe66b",
          stroke: "rgba(0,0,0,0.45)",
          line: "rgba(0,0,0,0.18)",
          text: "rgba(0,0,0,0.78)"
        };
      }
      return {
        fill: "#f4f4f4",
        stroke: "rgba(0,0,0,0.35)",
        line: "rgba(0,0,0,0.15)",
        text: "rgba(0,0,0,0.72)"
      };
    }

    // ë‚œì´ë„(ì¡°ê¸ˆ ë” ë¹ ë¥´ê²Œ)
    function getSpawnIntervalMs() {
      const base = 520;
      const perStage = 45 * stageIndex;
      const highBoost = (STAGES[stageIndex].school === "high") ? 80 : 0;
      return Math.max(160, base - perStage - highBoost);
    }

    function getFallSpeed() {
      const baseMin = 260;
      const baseMax = 380;

      const perStageMin = 22 * stageIndex;
      const perStageMax = 30 * stageIndex;

      const highAddMin = (STAGES[stageIndex].school === "high") ? 60 : 0;
      const highAddMax = (STAGES[stageIndex].school === "high") ? 90 : 0;

      const min = baseMin + perStageMin + highAddMin;
      const max = baseMax + perStageMax + highAddMax;

      return min + Math.random() * (max - min);
    }

    // ì˜¤ë””ì˜¤
    let audioCtx = null;
    let musicOn = true;
    let bgmTimer = null;

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playTone(freq, durationSec, type = "sine", gain = 0.06) {
      ensureAudio();
      const now = audioCtx.currentTime;

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      o.type = type;
      o.frequency.value = freq;

      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(now);
      o.stop(now + durationSec + 0.02);
    }

    function startBgm() {
      if (!musicOn) return;
      ensureAudio();
      if (audioCtx.state === "suspended") audioCtx.resume();
      stopBgm();

      const seq = [523.25, 659.25, 783.99, 659.25, 587.33, 659.25, 523.25, 392.00];
      let idx = 0;

      bgmTimer = setInterval(() => {
        if (!audioCtx || !musicOn) return;
        playTone(seq[idx % seq.length], 0.18, "square", 0.045);
        idx++;
      }, 210);
    }

    function stopBgm() {
      if (bgmTimer) {
        clearInterval(bgmTimer);
        bgmTimer = null;
      }
    }

    function playSuccessJingle() {
      if (!musicOn) return;
      ensureAudio();
      if (audioCtx.state === "suspended") audioCtx.resume();

      const notes = [523.25, 659.25, 783.99, 1046.50];
      let t = 0;
      for (const f of notes) {
        setTimeout(() => playTone(f, 0.16, "triangle", 0.08), t);
        t += 170;
      }
    }

    function toggleMusic() {
      musicOn = !musicOn;
      muteBtn.textContent = musicOn ? "ğŸ”Š ìŒì•…" : "ğŸ”‡ ë¬´ìŒ";
      if (musicOn && running) startBgm();
      else stopBgm();
    }

    // ê²Œì„ ìƒíƒœ
    let stageIndex = 0;

    let running = false;        // ë£¨í”„ê°€ ë„ëŠ”ì§€
    let stageActive = false;    // í˜„ì¬ ìŠ¤í…Œì´ì§€ê°€ ì§„í–‰ ì¤‘ì¸ì§€ (ì„±ê³µ í›„ì—ëŠ” falseë¡œ ë©ˆì¶¤)
    let pausedOverlay = false;

    const papers = [];
    let lastTime = 0;
    let lastSpawn = 0;

    let resolvedCount = 0; // í´ë¦­+ë°”ë‹¥ í¬í•¨ ì²˜ë¦¬ ìˆ˜
    let hitCount = 0;      // í´ë¦­ ìˆ˜

    let overlay = null;    // { type, until, text1, text2 }

    function currentStage() {
      return STAGES[stageIndex];
    }

    function updateHUD() {
      const s = currentStage();
      gradeEl.textContent = `í•™ë…„: ${s.label}`;
      progressEl.textContent = `ì§„í–‰: ${resolvedCount} / ${s.total} (í´ë¦­: ${hitCount})`;
    }

    function startStage() {
      // ìŠ¤í…Œì´ì§€ ì‹œì‘(ë˜ëŠ” ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ì‹œì‘)
      stageActive = true;
      pausedOverlay = false;
      overlay = null;

      resolvedCount = 0;
      hitCount = 0;
      papers.length = 0;

      lastSpawn = 0;
      updateHUD();
    }

    function resetGame() {
      running = false;
      stageActive = false;
      pausedOverlay = false;

      stageIndex = 0;

      resolvedCount = 0;
      hitCount = 0;

      papers.length = 0;
      lastTime = 0;
      lastSpawn = 0;
      overlay = null;

      stopBgm();
      draw();
      updateHUD();
    }

    function startLoopIfNeeded() {
      if (running) return;
      running = true;
      lastTime = performance.now();
      if (musicOn) startBgm();
      requestAnimationFrame(loop);
    }

    function spawnPaper() {
      const x = Math.random() * (canvas.width - PAPER_W);
      const y = -PAPER_H;
      const speed = getFallSpeed();
      papers.push({ x, y, w: PAPER_W, h: PAPER_H, speed });
    }

    function loop(t) {
      if (!running) return;

      const dt = (t - lastTime) / 1000;
      lastTime = t;

      if (stageActive && !pausedOverlay) {
        const s = currentStage();
        const interval = getSpawnIntervalMs();

        // ì´ ê°œìˆ˜ê¹Œì§€ë§Œ ìƒì„±
        if (resolvedCount + papers.length < s.total) {
          if (t - lastSpawn > interval) {
            spawnPaper();
            lastSpawn = t;
          }
        }

        // ì´ë™/ë°”ë‹¥ ì²˜ë¦¬
        for (let i = papers.length - 1; i >= 0; i--) {
          papers[i].y += papers[i].speed * dt;
          if (papers[i].y > canvas.height) {
            papers.splice(i, 1);
            resolvedCount += 1;
            checkStageEnd(t);
          }
        }

        checkStageEnd(t);
      }

      draw();

      // ì˜¤ë²„ë ˆì´ ì²˜ë¦¬
      if (overlay && t < overlay.until) {
        drawOverlay(overlay.type, overlay.text1, overlay.text2);
      } else if (overlay && t >= overlay.until) {
        const wasSuccess = overlay.type === "success";
        overlay = null;

        if (wasSuccess) {
          // ì„±ê³µ í›„: ìë™ ì§„í–‰í•˜ì§€ ì•Šê³  ë©ˆì¶¤
          stageActive = false;
          pausedOverlay = false;

          // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì¸ë±ìŠ¤ë§Œ ì˜¬ë ¤ë‘ê³ , Startë¥¼ ëˆŒëŸ¬ì•¼ ì‹œì‘
          if (stageIndex + 1 < STAGES.length) {
            stageIndex += 1;
            updateHUD();
            drawOverlay("success", "ì„±ê³µ!", "ë‹¤ìŒ ë‹¨ê³„ëŠ” ì‹œì‘ì„ ëˆ„ë¥´ì„¸ìš”");
          } else {
            // ë§ˆì§€ë§‰ê¹Œì§€ ì„±ê³µ
            running = false;
            stopBgm();
            drawOverlay("success", "ì „ë¶€ í†µê³¼!", "ê³ 3ê¹Œì§€ í´ë¦¬ì–´!");
          }
        } else {
          // ì‹¤íŒ¨: ë©ˆì¶¤
          running = false;
          stopBgm();
          drawFailFinal();
        }
      }

      updateHUD();

      if (running) requestAnimationFrame(loop);
    }

    function checkStageEnd(t) {
      const s = currentStage();
      const allSpawned = (resolvedCount + papers.length) >= s.total;

      if (allSpawned && papers.length === 0) {
        pausedOverlay = true;

        if (hitCount >= s.pass) {
          overlay = {
            type: "success",
            until: t + 1200,
            text1: "ì„±ê³µ!",
            text2: `${s.label} í†µê³¼!`
          };
          playSuccessJingle();
        } else {
          overlay = {
            type: "fail",
            until: t + 1400,
            text1: "ì‹¤íŒ¨!",
            text2: `í´ë¦­ ${hitCount}ê°œ (í•„ìš”: ${s.pass}ê°œ)`
          };
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ìƒë‹¨ ë°”ëŠ” í…ìŠ¤íŠ¸ ì—†ì´ ì•„ì£¼ ì•½í•˜ê²Œë§Œ ìœ ì§€(ì™„ì „ ë¹ˆ ëŠë‚Œ ë°©ì§€)
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(0, 0, canvas.width, 44);

      const style = getPaperStyle();

      for (const p of papers) {
        ctx.fillStyle = style.fill;
        ctx.fillRect(p.x, p.y, p.w, p.h);

        ctx.strokeStyle = style.stroke;
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        ctx.fillStyle = style.line;
        ctx.fillRect(p.x + 10, p.y + 14, p.w - 20, 3);
        ctx.fillRect(p.x + 10, p.y + 24, p.w - 34, 3);
        ctx.fillRect(p.x + 10, p.y + 34, p.w - 26, 3);

        ctx.fillStyle = style.text;
        ctx.font = "12px system-ui";
        ctx.fillText("ì‹œí—˜ì§€", p.x + 10, p.y + 50);
      }

      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 1);
      ctx.lineTo(canvas.width, canvas.height - 1);
      ctx.stroke();

      // ìŠ¤í…Œì´ì§€ê°€ ë©ˆì¶°ìˆì„ ë•Œ ì•ˆë‚´(ê²Œì„ ë‚´ë¶€ í…ìŠ¤íŠ¸)
      if (!stageActive && running) {
        ctx.fillStyle = "rgba(0,0,0,0.40)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = "center";
        ctx.fillStyle = "#fff";
        ctx.font = "18px system-ui";
        ctx.fillText("ì‹œì‘ì„ ëˆŒëŸ¬ ìŠ¤í…Œì´ì§€ ì‹œì‘", canvas.width / 2, canvas.height / 2);

        ctx.textAlign = "start";
      }

      // ë£¨í”„ê°€ ë©ˆì¶°ìˆê³ (ëŒ€ê¸°)ì¼ ë•Œë„ ê°€ì´ë“œ 1ì¤„
      if (!running) {
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = "center";
        ctx.fillStyle = "#fff";
        ctx.font = "18px system-ui";
        ctx.fillText("ì‹œì‘ì„ ëˆŒëŸ¬ í”Œë ˆì´", canvas.width / 2, canvas.height / 2);

        ctx.textAlign = "start";
      }
    }

    function drawOverlay(type, text1, text2) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.font = "30px system-ui";
      ctx.fillText(text1, canvas.width / 2, canvas.height / 2 - 12);

      ctx.font = "16px system-ui";
      ctx.fillText(text2, canvas.width / 2, canvas.height / 2 + 22);

      ctx.textAlign = "start";
    }

    function drawFailFinal() {
      const s = currentStage();

      ctx.fillStyle = "rgba(0,0,0,0.60)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "26px system-ui";
      ctx.fillText("FAILED", canvas.width / 2, canvas.height / 2 - 26);

      ctx.font = "16px system-ui";
      ctx.fillText(`${s.label}ì—ì„œ ì‹¤íŒ¨`, canvas.width / 2, canvas.height / 2 + 6);
      ctx.fillText(`í´ë¦­ ${hitCount}ê°œ / í•„ìš” ${s.pass}ê°œ`, canvas.width / 2, canvas.height / 2 + 30);
      ctx.fillText("ë¦¬ì…‹ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘", canvas.width / 2, canvas.height / 2 + 56);

      ctx.textAlign = "start";
    }

    // ì…ë ¥: í„°ì¹˜/í´ë¦­
    function handlePointer(e) {
      if (!running) return;
      if (!stageActive) return;
      if (pausedOverlay) return;

      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);

      for (let i = papers.length - 1; i >= 0; i--) {
        const p = papers[i];
        if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
          papers.splice(i, 1);
          hitCount += 1;
          resolvedCount += 1;
          return;
        }
      }
    }

    canvas.addEventListener("pointerdown", handlePointer);

    startBtn.addEventListener("click", () => {
      // ì˜¤ë””ì˜¤ ì •ì±… ëŒ€ì‘
      ensureAudio();
      if (audioCtx.state === "suspended") audioCtx.resume();

      // ë£¨í”„ê°€ ë©ˆì¶°ìˆìœ¼ë©´ ë£¨í”„ ì‹œì‘
      startLoopIfNeeded();

      // í˜„ì¬ ìŠ¤í…Œì´ì§€ê°€ ì§„í–‰ ì¤‘ì´ ì•„ë‹ˆë©´(ëŒ€ê¸°/ì„±ê³µ í›„) ìŠ¤í…Œì´ì§€ ì‹œì‘
      if (!stageActive) {
        startStage();
      }
    });

    restartBtn.addEventListener("click", () => {
      resetGame();
    });

    muteBtn.addEventListener("click", toggleMusic);

    // ì´ˆê¸° í™”ë©´
    updateHUD();
    draw();
  </script>
</body>
</html>
